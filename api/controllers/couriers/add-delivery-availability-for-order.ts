import moment from "moment";
import { Slot } from "../../interfaces/vendors/slot";
import util from 'util';

module.exports = {
  friendlyName: "Add delivery availability to order",

  description:
    "For deliveryPartners to verify that they have riders available to service an order before the order has been sent to the vendor to be confirmed.",

  inputs: {
    vegiOrderId: {
      type: "string",
      description: "The Public id relating to the order in the vegi db",
      required: true,
    },
    deliveryId: {
      type: "string",
      description:
        "The delivery id generated by the deliveryPartner to be added here so that it can be added to the order for tracking.",
      required: true,
    },
    deliveryPartnerAccepted: {
      type: "boolean",
      required: true,
    },
    deliveryPartnerId: {
      type: "number",
      required: true,
    }
  },

  exits: {
    orderAlreadyHasDeliveryPartner: {
      statusCode: 401,
      description: "A deliveryPartner has already accepted this order",
    },
    deliveryPartnerUnableToServiceSlot: {
      statusCode: 404,
      description: "DeliveryPartner does not have a slot to service this order",
    },
    notFound: {
      statusCode: 404,
      description: "No order found for order id",
    },
    forbidden: {
      statusCode: 401,
      description: "A deliveryPartner has already accepted this order",
    },
  },

  fn: async function (inputs, exits) {
    // Method protected by config/policies.js
    let order;
    try {
      order = await Order.findOne({
        publicId: inputs.vegiOrderId,
      });
    } catch (error) {
      sails.log.error(
        `Request to add delivery availability for order with vegi public id: ${inputs.vegiOrderId} -> failed to find this order. Error: ${error}`
      );
      order = null;
      return exits.notFound();
    }

    if (!order) {
      sails.log(`order not found with public id: ${inputs.vegiOrderId}`);
      return exits.notFound();
    }

    const isAuthorisedForDPOps =
      await sails.helpers.isAuthorisedForDeliveryPartner.with({
        userId: this.req.session.userId,
        deliveryPartnerId: inputs.deliveryPartnerId,
      });
    if (!isAuthorisedForDPOps) {
      return exits.forbidden();
    } else if (
      order.deliveryPartnerAccepted ||
      order.deliveryPartnerConfirmed ||
      order.deliveryPartner
    ) {
      sails.log(`This DeliveryPartner has previously confirmed the delivery, they cannot accept the the delivery again.`);
      return exits.orderAlreadyHasDeliveryPartner(); //NOTE: cannot be cancelled after this stage
    }

    const deliveryPartner = await DeliveryPartner.findOne(
      inputs.deliveryPartnerId
    ).populate('deliveryFulfilmentMethod');
    if(!deliveryPartner){
      sails.log(
        `Delivery partner with id: ${inputs.deliveryPartnerId} not found.`
      );
      return exits.notFound();
    }

    try {
	    if (deliveryPartner.deliveryFulfilmentMethod) {
	      // Check that delivery partner can service this delivery slot
	      const dPdeliverySlotsI = await sails.helpers
          .getAvailableSlots(
            moment
              .utc(order.fulfilmentSlotFrom, "YYYY-MM-DD HH:mm:ss")
              .format("YYYY-MM-DD"),
            deliveryPartner.deliveryFulfilmentMethod.id
          );
        const dPdeliverySlots = dPdeliverySlotsI.map((slot) => Slot.from(slot));
        // sails.log(
        //   `Order between ${order.fulfilmentSlotFrom} and ${order.fulfilmentSlotTo}`
        // );
        // sails.log(util.inspect(dPdeliverySlots, {depth: null}));
	      const slotOk =
	        dPdeliverySlots.filter((slot) => {
	          return moment
              .utc(order.fulfilmentSlotFrom, "YYYY-MM-DD HH:mm:ss")
              .isSameOrAfter(slot.startTime) &&
              moment
                .utc(order.fulfilmentSlotFrom, "YYYY-MM-DD HH:mm:ss")
                .isSameOrBefore(slot.endTime) &&
              moment
                .utc(order.fulfilmentSlotTo, "YYYY-MM-DD HH:mm:ss")
                .isSameOrAfter(slot.startTime) &&
              moment
                .utc(order.fulfilmentSlotTo, "YYYY-MM-DD HH:mm:ss")
                .isSameOrBefore(slot.endTime);
	        }).length > 0;
	      if (!slotOk) {
	        return exits.deliveryPartnerUnableToServiceSlot();
	      }
	    }
    } catch (error) {
      sails.log.error(`Unable to check available slots for delivery partner to accept order for error: ${error}`);
    }

    await Order.updateOne(order.id).set({
      deliveryPartnerAccepted: inputs.deliveryPartnerAccepted,
      deliveryPartner: inputs.deliveryPartnerAccepted
        ? deliveryPartner.id
        : null,
      deliveryId: inputs.deliveryId,
      deliveryPartnerConfirmed: false,
    });

    // All done.
    return exits.success();
  },
};
