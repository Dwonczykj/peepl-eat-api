module.exports = {
  friendlyName: "Cancel delivery",

  description: "",

  inputs: {
    vegiOrderId: {
      type: "string",
      description: "The public id relating to the order in the vegi db",
      required: true,
    },
    deliveryId: {
      type: "string",
      description: "The delivery id generated by the deliveryPartner",
      required: true,
    },
  },

  exits: {
    otherDeliveryPartnerRegisteredToOrder: {
      statusCode: 401,
    },
    deliveryPartnerAlreadyConfirmedOrder: {
      statusCode: 401,
    },
  },

  fn: async function (inputs, exits) {
    var order = await Order.findOne({
      deliveryId: inputs.deliveryId,
      completedFlag: "",
    }).populate("deliveryPartner");

    if (!order) {
      return exits.notFound();
    }

    if (
      order.deliveryPartner.id !== null &&
      order.deliveryPartner.id !== undefined &&
      order.deliveryPartner.id !== this.req.session.userId
    ) {
      return exits.otherDeliveryPartnerRegisteredToOrder();
    } else if (
      order.deliveryPartner.id === this.req.session.userId &&
      order.deliveryPartnerConfirmed
    ) {
      // This DeliveryPartner has previously confirmed the delivery, they cannot cancel the delivery after this.
      return exits.deliveryPartnerAlreadyConfirmedOrder(); //NOTE: cannot be cancelled after this stage
    }

    await Order.updateOne({ deliveryId: inputs.deliveryId }).set({
      deliveryId: null,
      deliveryPartnerAccepted: false,
      deliveryPartner: null,
      deliveryPartnerConfirmed: false,
    });

    await sails.helpers.sendFirebaseNotification.with({
      topic: "order-" + order.publicId,
      title: "Rider Cancelled! ðŸš¨",
      body: "Your order has been cancelled by the rider. \nWe will find a new rider and notify you again when we do. \n\nAlternatively open vegi to manage to your order.",
    });

    // All done.
    return;
  },
};
